

from typing import *

import numpy as np

from ..common.helpers import is_bounds_valid
from .basegenerator import BaseGenerator


__all__ = ("ExploitExploreGenerator",)


class ExploitExploreGenerator(BaseGenerator):
    """ This generator blends a randomly generated point with the location of an existing optimizer. The optimizer is
        chosen based on a roulette selection.
    """

    def __init__(self, bounds: Sequence[Tuple[float, float]], max_func_calls: int, focus: float = 1):
        """

        Parameters
        ----------
        bounds: Sequence[Tuple[float, float]]
            Min and max bounds for each parameter.
        max_func_calls: int
            Maximum function calls allowed for the optimization, at and beyond this point there is a 100% chance that a
            previously evaluated point will be returned by the generator.
        focus: float = 1
            The blend parameter between random point and incumbent is given as p=(f_calls / max_f_calls)^focus. At p=0
            the random point is taken at p=1 the incumbent is chosen. If focus<1 points are more like the incumbent, if
            focus>1 points are more like the random. Default is focus=1 which has a linear growth from random to
            incumbent. The new pt is calculated as new_pt = p*incumbent_pt + (1-p)*random_pt.
        """
        super().__init__()

        if not isinstance(max_func_calls, int):
            raise TypeError("Cannot parse max_func_calls, int required.")
        if max_func_calls < 2:
            raise ValueError("Cannot parse max_func_calls, int > 1 required.")
        self.max_func_calls = max_func_calls

        if focus <= 0:
            raise ValueError("Cannot parse focus, float larger than 0 required.")
        self.focus = focus

        if is_bounds_valid(bounds):
            bnds = np.array(bounds)
            self.min = bnds[:, 0]
            self.max = bnds[:, 1]
            self.n_params = len(bnds)

    def generate(self, manager: 'GloMPOManager') -> np.ndarray:
        x_track = []
        f_track = []

        # Random Point
        random = (self.max - self.min) * np.random.random(self.n_params) + self.min
        self.logger.debug(f"Random = {random}")

        for o in range(1, manager.o_counter):
            history = manager.opt_log.get_history(o)
            if history:
                i_max = len(history)
                i_best = history[i_max]['i_best']
                if i_best == -1:
                    continue
                f_best = history[i_best]['fx']
                x_best = history[i_best]['x']

                x_track.append(x_best)
                f_track.append(f_best)

        x_track = np.array(x_track)
        f_track = np.array(f_track)

        assert len(f_track) == len(x_track)

        if len(f_track) == 0:
            return random

        # Roulette Selection
        shift = f_track - np.min(f_track)
        revert = np.max(shift) - shift
        if np.all(revert == 0):
            return random
        prob = revert / np.sum(revert)

        select = np.random.choice(range(len(f_track)), p=prob)
        incumbent = x_track[select]
        self.logger.debug(f"Selected incumbent from Optimizer {select} = {incumbent}")

        # Blending parameter
        f_calls = np.clip(manager.f_counter / self.max_func_calls, 0, 1)
        alpha = f_calls ** self.focus
        self.logger.debug(f"Selected alpha = {alpha}")

        # New point
        generated = alpha*incumbent + (1-alpha)*random
        self.logger.debug(f"Generated = {generated}")

        return generated
